#!/usr/bin/env python3
"""
Cloud Infrastructure Penetration Testing Script
Author: Cloud Security Team
Purpose: AWS, Azure, GCP security assessment and vulnerability scanning
"""

import argparse
import json
import sys
from typing import Dict, List, Tuple
import subprocess
import re


class CloudPentestScanner:
    """Base class for cloud penetration testing"""

    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.findings = []
        self.passed_checks = []

    def log(self, message: str, level: str = "INFO"):
        """Log messages based on verbosity level"""
        if self.verbose or level in ["ERROR", "CRITICAL"]:
            print(f"[{level}] {message}")

    def add_finding(self, severity: str, category: str, issue: str, remediation: str):
        """Add a security finding"""
        self.findings.append({
            "severity": severity,
            "category": category,
            "issue": issue,
            "remediation": remediation
        })

    def add_passed_check(self, check: str):
        """Log a passed security check"""
        self.passed_checks.append(check)
        self.log(f"PASS: {check}", "DEBUG")


class AWSPentest(CloudPentestScanner):
    """AWS-specific penetration testing"""

    def __init__(self, profile: str = None, verbose: bool = False):
        super().__init__(verbose)
        self.profile = profile or "default"
        self.aws_cmd = ["aws"]
        if self.profile != "default":
            self.aws_cmd.extend(["--profile", self.profile])

    def test_s3_buckets(self) -> List[Dict]:
        """Check for S3 bucket misconfigurations"""
        self.log("Testing S3 bucket security...")
        issues = []

        try:
            # List all buckets
            cmd = self.aws_cmd + ["s3api", "list-buckets", "--query", "Buckets[].Name", "--output", "json"]
            result = subprocess.run(cmd, capture_output=True, text=True)
            buckets = json.loads(result.stdout)
            self.log(f"Found {len(buckets)} S3 buckets")

            for bucket in buckets:
                # Check bucket encryption
                if not self._check_bucket_encryption(bucket):
                    self.add_finding(
                        severity="HIGH",
                        category="S3",
                        issue=f"S3 bucket '{bucket}' does not have encryption enabled",
                        remediation="Enable Server-Side Encryption (SSE-S3 or SSE-KMS)"
                    )
                else:
                    self.add_passed_check(f"S3 bucket '{bucket}' has encryption enabled")

                # Check bucket versioning
                if not self._check_bucket_versioning(bucket):
                    self.add_finding(
                        severity="MEDIUM",
                        category="S3",
                        issue=f"S3 bucket '{bucket}' versioning is not enabled",
                        remediation="Enable versioning to protect against accidental deletion"
                    )

                # Check bucket public access block
                if not self._check_bucket_public_access_block(bucket):
                    self.add_finding(
                        severity="CRITICAL",
                        category="S3",
                        issue=f"S3 bucket '{bucket}' does not have public access block",
                        remediation="Enable 'Block all public access' settings"
                    )

        except Exception as e:
            self.log(f"Error testing S3: {str(e)}", "ERROR")

        return issues

    def _check_bucket_encryption(self, bucket: str) -> bool:
        """Check if bucket has encryption"""
        try:
            cmd = self.aws_cmd + ["s3api", "get-bucket-encryption", "--bucket", bucket]
            result = subprocess.run(cmd, capture_output=True, text=True)
            return result.returncode == 0
        except:
            return False

    def _check_bucket_versioning(self, bucket: str) -> bool:
        """Check if bucket versioning is enabled"""
        try:
            cmd = self.aws_cmd + ["s3api", "get-bucket-versioning", "--bucket", bucket, "--query", "Status"]
            result = subprocess.run(cmd, capture_output=True, text=True)
            status = result.stdout.strip().strip('"')
            return status == "Enabled"
        except:
            return False

    def _check_bucket_public_access_block(self, bucket: str) -> bool:
        """Check if bucket has public access block"""
        try:
            cmd = self.aws_cmd + ["s3api", "get-public-access-block", "--bucket", bucket]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                config = json.loads(result.stdout)
                pab = config.get("PublicAccessBlockConfiguration", {})
                return all([
                    pab.get("BlockPublicAcls"),
                    pab.get("BlockPublicPolicy"),
                    pab.get("IgnorePublicAcls"),
                    pab.get("RestrictPublicBuckets")
                ])
            return False
        except:
            return False

    def test_iam_security(self) -> List[Dict]:
        """Check for IAM misconfigurations"""
        self.log("Testing IAM security...")
        issues = []

        try:
            # Check for root account MFA
            self.log("Checking root account MFA status...")

            # Check for overly permissive policies
            cmd = self.aws_cmd + ["iam", "list-users", "--query", "Users[].UserName", "--output", "json"]
            result = subprocess.run(cmd, capture_output=True, text=True)
            users = json.loads(result.stdout)

            for user in users:
                if self._check_user_mfa(user):
                    self.add_passed_check(f"IAM user '{user}' has MFA enabled")
                else:
                    self.add_finding(
                        severity="HIGH",
                        category="IAM",
                        issue=f"IAM user '{user}' does not have MFA enabled",
                        remediation="Enable MFA for all IAM users with console access"
                    )

        except Exception as e:
            self.log(f"Error testing IAM: {str(e)}", "ERROR")

        return issues

    def _check_user_mfa(self, username: str) -> bool:
        """Check if user has MFA enabled"""
        try:
            cmd = self.aws_cmd + ["iam", "list-mfa-devices", "--user-name", username, "--query", "MFADevices"]
            result = subprocess.run(cmd, capture_output=True, text=True)
            devices = json.loads(result.stdout)
            return len(devices) > 0
        except:
            return False

    def test_ec2_security(self) -> List[Dict]:
        """Check for EC2 security group misconfigurations"""
        self.log("Testing EC2 security groups...")
        issues = []

        try:
            cmd = self.aws_cmd + ["ec2", "describe-security-groups", "--query", "SecurityGroups[].{Name:GroupName,Id:GroupId,Rules:IpPermissions[]}"]
            result = subprocess.run(cmd, capture_output=True, text=True)
            security_groups = json.loads(result.stdout)

            for sg in security_groups:
                for rule in sg.get("Rules", []):
                    # Check for 0.0.0.0/0 access
                    for ip_range in rule.get("IpRanges", []):
                        if ip_range.get("CidrIp") == "0.0.0.0/0":
                            self.add_finding(
                                severity="HIGH",
                                category="EC2",
                                issue=f"Security Group '{sg['Id']}' allows unrestricted access from 0.0.0.0/0",
                                remediation="Restrict source IPs to specific trusted ranges"
                            )

        except Exception as e:
            self.log(f"Error testing EC2: {str(e)}", "ERROR")

        return issues

    def run_all_tests(self):
        """Run all AWS penetration tests"""
        self.log("Starting AWS penetration testing...")
        self.test_s3_buckets()
        self.test_iam_security()
        self.test_ec2_security()
        self.log(f"Testing complete. Found {len(self.findings)} vulnerabilities.")


class AzurePentest(CloudPentestScanner):
    """Azure-specific penetration testing"""

    def __init__(self, subscription: str = None, verbose: bool = False):
        super().__init__(verbose)
        self.subscription = subscription
        self.log("Azure penetration testing module initialized")

    def test_storage_accounts(self) -> List[Dict]:
        """Check Azure storage account security"""
        self.log("Testing Azure storage accounts...")
        # Implementation would follow Azure CLI commands
        pass

    def run_all_tests(self):
        """Run all Azure penetration tests"""
        self.log("Starting Azure penetration testing...")
        self.test_storage_accounts()


class GCPPentest(CloudPentestScanner):
    """GCP-specific penetration testing"""

    def __init__(self, project: str = None, verbose: bool = False):
        super().__init__(verbose)
        self.project = project
        self.log("GCP penetration testing module initialized")

    def test_bucket_security(self) -> List[Dict]:
        """Check GCS bucket security"""
        self.log("Testing GCS bucket security...")
        # Implementation would follow gsutil commands
        pass

    def run_all_tests(self):
        """Run all GCP penetration tests"""
        self.log("Starting GCP penetration testing...")
        self.test_bucket_security()


def generate_report(scanner: CloudPentestScanner, output_format: str = "json"):
    """Generate penetration test report"""
    report = {
        "summary": {
            "total_findings": len(scanner.findings),
            "total_passed": len(scanner.passed_checks),
            "critical": len([f for f in scanner.findings if f["severity"] == "CRITICAL"]),
            "high": len([f for f in scanner.findings if f["severity"] == "HIGH"]),
            "medium": len([f for f in scanner.findings if f["severity"] == "MEDIUM"]),
            "low": len([f for f in scanner.findings if f["severity"] == "LOW"])
        },
        "findings": scanner.findings,
        "passed_checks": scanner.passed_checks
    }

    if output_format == "json":
        return json.dumps(report, indent=2)
    return report


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="Cloud Infrastructure Penetration Testing Tool")
    parser.add_argument("--cloud", choices=["aws", "azure", "gcp", "all"], default="all",
                        help="Cloud provider to test")
    parser.add_argument("--aws-profile", default="default", help="AWS profile to use")
    parser.add_argument("--azure-subscription", help="Azure subscription ID")
    parser.add_argument("--gcp-project", help="GCP project ID")
    parser.add_argument("--output", choices=["json", "text"], default="json", help="Output format")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")

    args = parser.parse_args()

    scanners = []

    if args.cloud in ["aws", "all"]:
        scanners.append(("AWS", AWSPentest(profile=args.aws_profile, verbose=args.verbose)))

    if args.cloud in ["azure", "all"]:
        scanners.append(("Azure", AzurePentest(subscription=args.azure_subscription, verbose=args.verbose)))

    if args.cloud in ["gcp", "all"]:
        scanners.append(("GCP", GCPPentest(project=args.gcp_project, verbose=args.verbose)))

    for name, scanner in scanners:
        print(f"\n=== Testing {name} ===")
        scanner.run_all_tests()
        report = generate_report(scanner, output_format=args.output)
        print(report)


if __name__ == "__main__":
    main()
